import { Injectable, inject } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Utils } from '../shared/utils';
import { DataService } from './data.service';
import { CONFIG, VIEWS } from '../shared/providers';
import * as i0 from "@angular/core";
export class ExplorerService {
    constructor() {
        this.dataService = inject(DataService);
        this.config = inject(CONFIG);
        this.views = inject(VIEWS);
        this.internalTree = Utils.createNode(this.config.homeNodeName || 'Home', 0, false, {}, true);
        this.flatPointers = { [this.internalTree.id]: this.internalTree };
        this.selectedNodes$$ = new BehaviorSubject([]);
        this.openedNode$$ = new BehaviorSubject(undefined);
        this.root$$ = new BehaviorSubject(this.internalTree);
        this.currentView$ = new BehaviorSubject(this.config.defaultView || this.views[0].name);
        /**
         * An Observable that emits the currently selected nodes in the explorer.
         * Subscribers can use this to react to changes in the selection.
         */
        this.selection$ = this.selectedNodes$$.asObservable();
        /**
         * An Observable that emits the currently opened directory in the explorer.
         * Subscribers can use this to react to changes in the opened directory.
         */
        this.openedDir$ = this.openedNode$$.asObservable();
        /**
         * An Observable that emits the root node of the explorer.
         * Subscribers can use this to react to changes in the root node.
         */
        this.root$ = this.root$$.asObservable();
    }
    /**
     * Returns the node with the given id.
     * @param id The id of the node to retrieve.
     */
    getNode(id) {
        return this.flatPointers[id];
    }
    /**
     * Sets the selected nodes in the explorer.
     * @param nodes The nodes to select.
     */
    select(nodes) {
        this.selectedNodes$$.next(nodes);
    }
    /**
     * Opens the node with the given id. If no id is provided, the root node is opened.
     * @param id The id of the node to open.
     */
    openNode(id) {
        if (!id) {
            id = this.internalTree.id;
        }
        this.getContent(id).subscribe(() => {
            const parent = this.flatPointers[id];
            this.openedNode$$.next(parent);
            this.selectedNodes$$.next([]);
        });
    }
    /**
     * Expands the node with the given id.
     * @param id The id of the node to expand.
     */
    expand(id) {
        const parent = this.flatPointers[id];
        parent.expanded = true;
        this.getContent(id).subscribe();
    }
    collapse(id) {
        const parent = this.flatPointers[id];
        parent.expanded = false;
        this.root$$.next(this.internalTree);
    }
    /**
     * Creates a new directory with the given name in the currently opened directory.
     * @param name The name of the new directory.
     */
    createDir(name) {
        if (this.config.features?.createDir === false) {
            throw new Error('Create directory feature is disabled');
        }
        const parent = this.openedNode$$.value;
        this.dataService.createDir(parent.data, name).subscribe(() => {
            this.refresh();
        });
    }
    /**
     * Refreshes the currently opened node.
     */
    refresh() {
        this.dataService.refresh().subscribe(data => this.openNode(this.openedNode$$.value.id));
    }
    /**
     * Renames the currently selected node.
     * @param name The new name for the node.
     */
    rename(name) {
        if (this.config.features?.rename === false) {
            throw new Error('Rename feature is disabled');
        }
        const nodes = this.selectedNodes$$.value;
        if (nodes.length > 1) {
            throw new Error('Multiple selection rename not supported');
        }
        if (nodes.length === 0) {
            throw new Error('Nothing selected to rename');
        }
        const node = nodes[0];
        this.dataService.rename(node.data, name).subscribe(() => {
            this.refresh();
        });
    }
    /**
     * Removes the currently selected nodes.
     */
    remove() {
        if (this.config.features?.delete === false) {
            throw new Error('Delete feature is disabled');
        }
        const selection = this.selectedNodes$$.value;
        if (selection.length === 0) {
            throw new Error('Nothing selected to remove');
        }
        const targets = selection.map((node) => this.flatPointers[node.id].data);
        this.dataService.delete(targets).subscribe(() => {
            this.refresh();
        });
    }
    /**
     * Uploads the given files to the currently opened directory.
     * @param files The files to upload.
     */
    runFile(){
        const target = this.selectedNodes$$.value[0];
        this.dataService.runFile(target.data);
    }

    upload(files) {
        if (this.config.features?.upload === false) {
            throw new Error('Upload feature is disabled');
        }
        const node = this.openedNode$$.value;
        this.dataService.uploadFiles(node.data, files).subscribe(() => {
            this.refresh();
        });
    }
    /**
     * Downloads the currently selected file.
     */
    download() {
        if (this.config.features?.download === false) {
            throw new Error('Download feature is disabled');
        }
        const target = this.selectedNodes$$.value[0];
        this.dataService.downloadFile(target.data).subscribe(() => {
            this.refresh();
        });
    }
    /**
     * Open node and get all parent nodes
     * Ideal for opening a previously opened node by value
     */
    openTree(data) {
        this.dataService.openTree(data).subscribe((dataNodes) => {
            const queue = [
                {
                    parent: this.internalTree,
                    children: dataNodes,
                },
            ];
            let lastParent = this.internalTree;
            while (queue.length > 0) {
                const { parent, children } = queue.shift();
                lastParent = parent;
                children.forEach((child) => {
                    const node = Utils.createNode(this.dataService.getName(child.data), parent.id, child.isLeaf, child.data);
                    parent.children.push(node);
                    this.flatPointers[node.id] = node;
                    if (!node.isLeaf && child.children && child.children.length > 0) {
                        parent.expanded = true;
                        queue.push({
                            parent: node,
                            children: child.children,
                        });
                    }
                });
            }
            this.root$$.next(this.internalTree);
            this.openedNode$$.next(lastParent);
            this.selectedNodes$$.next([]);
        });
    }
    getContent(id) {
        const parent = this.flatPointers[id];
        if (!parent) {
            throw new Error('Node not found');
        }
        //if (parent.isLeaf) {
        //    throw new Error('Cannot open a file node');
        //}
        return this.dataService.getContent(parent.data).pipe(tap(({ files, dirs }) => {
            const newDirNodes = dirs.map((data) => Utils.createNode(this.dataService.getName(data), id, false, data));
            const newFileNodes = files.map((data) => Utils.createNode(this.dataService.getName(data), id, true, data));
            const newChildren = newDirNodes.concat(newFileNodes);
            const added = newChildren.filter((c) => !parent.children.find((o) => Utils.compareObjects(o.data, c.data)));
            const removed = parent.children.filter((o) => !newChildren.find((c) => Utils.compareObjects(o.data, c.data)));
            removed.forEach((c) => {
                const index = parent.children.findIndex((o) => o.id === c.id);
                parent.children.splice(index, 1);
                delete this.flatPointers[c.id];
            });
            added.forEach((c) => {
                parent.children.push(c);
                this.flatPointers[c.id] = c;
            });
            const nodeChildren = parent.children.filter((c) => !c.isLeaf);
            const leafChildren = parent.children.filter((c) => c.isLeaf);
            parent.children = nodeChildren.concat(leafChildren);
            this.root$$.next(this.internalTree);
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.2", ngImport: i0, type: ExplorerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.2", ngImport: i0, type: ExplorerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.2", ngImport: i0, type: ExplorerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwbG9yZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1leHBsb3Jlci9zcmMvbGliL3NlcnZpY2VzL2V4cGxvcmVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN2QyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLHFCQUFxQixDQUFDOztBQUtwRCxNQUFNLE9BQU8sZUFBZTtJQUg1QjtRQUlZLGdCQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2xDLFdBQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDeEIsVUFBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0QixpQkFBWSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLElBQUksTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3hGLGlCQUFZLEdBQXNCLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUV2RSxvQkFBZSxHQUFHLElBQUksZUFBZSxDQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELGlCQUFZLEdBQUcsSUFBSSxlQUFlLENBQW9CLFNBQVMsQ0FBQyxDQUFDO1FBQ2pFLFdBQU0sR0FBRyxJQUFJLGVBQWUsQ0FBUSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEQsaUJBQVksR0FBRyxJQUFJLGVBQWUsQ0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTFHOzs7V0FHRztRQUNhLGVBQVUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRWpFOzs7V0FHRztRQUNhLGVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRTlEOzs7V0FHRztRQUNhLFVBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO0tBME50RDtJQXhORzs7O09BR0c7SUFDSSxPQUFPLENBQUMsRUFBVTtRQUNyQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxLQUFjO1FBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7O09BR0c7SUFDSSxRQUFRLENBQUMsRUFBVztRQUN2QixJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ0wsRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO1NBQzdCO1FBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQy9CLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRyxDQUFDLENBQUM7WUFDdEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLEVBQVU7UUFDcEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNyQyxNQUFNLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFTSxRQUFRLENBQUMsRUFBVTtRQUN0QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksU0FBUyxDQUFDLElBQVk7UUFDekIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxTQUFTLEtBQUssS0FBSyxFQUFFO1lBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztTQUMzRDtRQUVELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUMxRCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPO1FBQ1YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLElBQVk7UUFDdEIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxNQUFNLEtBQUssS0FBSyxFQUFFO1lBQ3hDLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztTQUNqRDtRQUVELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDO1FBQ3pDLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1NBQzlEO1FBQ0QsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7U0FDakQ7UUFFRCxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ3BELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU07UUFDVCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLE1BQU0sS0FBSyxLQUFLLEVBQUU7WUFDeEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUM7UUFDN0MsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7U0FDakQ7UUFFRCxNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6RSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQzVDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSSxNQUFNLENBQUMsS0FBZTtRQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLE1BQU0sS0FBSyxLQUFLLEVBQUU7WUFDeEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFNLENBQUM7UUFDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQzFELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7UUFDWCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLFFBQVEsS0FBSyxLQUFLLEVBQUU7WUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1NBQ25EO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDdEQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ25CLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFFBQVEsQ0FBQyxJQUFVO1FBQ3RCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFO1lBQ3BELE1BQU0sS0FBSyxHQUFHO2dCQUNWO29CQUNJLE1BQU0sRUFBRSxJQUFJLENBQUMsWUFBWTtvQkFDekIsUUFBUSxFQUFFLFNBQVM7aUJBQ3RCO2FBQ0osQ0FBQztZQUVGLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDbkMsT0FBTyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDckIsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFHLENBQUM7Z0JBQzVDLFVBQVUsR0FBRyxNQUFNLENBQUM7Z0JBQ3BCLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDdkIsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDekcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzNCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7d0JBQzdELE1BQU0sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO3dCQUN2QixLQUFLLENBQUMsSUFBSSxDQUFDOzRCQUNQLE1BQU0sRUFBRSxJQUFJOzRCQUNaLFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUTt5QkFDM0IsQ0FBQyxDQUFDO3FCQUNOO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2FBQ047WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU8sVUFBVSxDQUFDLEVBQVU7UUFDekIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVyQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUNoRCxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFO1lBQ3BCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzFHLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzNHLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDckQsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUcsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFOUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNsQixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzlELE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDakMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNuQyxDQUFDLENBQUMsQ0FBQztZQUVILEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNoQyxDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5RCxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzdELE1BQU0sQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUVwRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEMsQ0FBQyxDQUFDLENBQ0wsQ0FBQztJQUNOLENBQUM7OEdBclBRLGVBQWU7a0hBQWYsZUFBZSxjQUZaLE1BQU07OzJGQUVULGVBQWU7a0JBSDNCLFVBQVU7bUJBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElOb2RlLCBEaWN0aW9uYXJ5LCBEYXRhIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzJztcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnLi9kYXRhLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ09ORklHLCBWSUVXUyB9IGZyb20gJy4uL3NoYXJlZC9wcm92aWRlcnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBFeHBsb3JlclNlcnZpY2Uge1xuICAgIHByaXZhdGUgZGF0YVNlcnZpY2UgPSBpbmplY3QoRGF0YVNlcnZpY2UpO1xuICAgIHByaXZhdGUgY29uZmlnID0gaW5qZWN0KENPTkZJRyk7XG4gICAgcHJpdmF0ZSB2aWV3cyA9IGluamVjdChWSUVXUyk7XG4gICAgcHJpdmF0ZSBpbnRlcm5hbFRyZWUgPSBVdGlscy5jcmVhdGVOb2RlKHRoaXMuY29uZmlnLmhvbWVOb2RlTmFtZSB8fCAnSG9tZScsIDAsIGZhbHNlLCB7fSwgdHJ1ZSk7XG4gICAgcHJpdmF0ZSBmbGF0UG9pbnRlcnM6IERpY3Rpb25hcnk8SU5vZGU+ID0geyBbdGhpcy5pbnRlcm5hbFRyZWUuaWRdOiB0aGlzLmludGVybmFsVHJlZSB9O1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RlZE5vZGVzJCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PElOb2RlW10+KFtdKTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wZW5lZE5vZGUkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SU5vZGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gICAgcHJpdmF0ZSByZWFkb25seSByb290JCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PElOb2RlPih0aGlzLmludGVybmFsVHJlZSk7XG4gICAgcHVibGljIHJlYWRvbmx5IGN1cnJlbnRWaWV3JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPih0aGlzLmNvbmZpZy5kZWZhdWx0VmlldyB8fCB0aGlzLnZpZXdzWzBdLm5hbWUpO1xuXG4gICAgLyoqXG4gICAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZXMgaW4gdGhlIGV4cGxvcmVyLlxuICAgICAqIFN1YnNjcmliZXJzIGNhbiB1c2UgdGhpcyB0byByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IHNlbGVjdGlvbiQgPSB0aGlzLnNlbGVjdGVkTm9kZXMkJC5hc09ic2VydmFibGUoKTtcblxuICAgIC8qKlxuICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudGx5IG9wZW5lZCBkaXJlY3RvcnkgaW4gdGhlIGV4cGxvcmVyLlxuICAgICAqIFN1YnNjcmliZXJzIGNhbiB1c2UgdGhpcyB0byByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBvcGVuZWQgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBvcGVuZWREaXIkID0gdGhpcy5vcGVuZWROb2RlJCQuYXNPYnNlcnZhYmxlKCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgZXhwbG9yZXIuXG4gICAgICogU3Vic2NyaWJlcnMgY2FuIHVzZSB0aGlzIHRvIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIHJvb3Qgbm9kZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgcm9vdCQgPSB0aGlzLnJvb3QkJC5hc09ic2VydmFibGUoKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbm9kZSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Tm9kZShpZDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXRQb2ludGVyc1tpZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0ZWQgbm9kZXMgaW4gdGhlIGV4cGxvcmVyLlxuICAgICAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3Qobm9kZXM6IElOb2RlW10pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzJCQubmV4dChub2Rlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gaWQuIElmIG5vIGlkIGlzIHByb3ZpZGVkLCB0aGUgcm9vdCBub2RlIGlzIG9wZW5lZC5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBub2RlIHRvIG9wZW4uXG4gICAgICovXG4gICAgcHVibGljIG9wZW5Ob2RlKGlkPzogbnVtYmVyKSB7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5pbnRlcm5hbFRyZWUuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldENvbnRlbnQoaWQpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZsYXRQb2ludGVyc1tpZCFdO1xuICAgICAgICAgICAgdGhpcy5vcGVuZWROb2RlJCQubmV4dChwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzJCQubmV4dChbXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbm9kZSB0byBleHBhbmQuXG4gICAgICovXG4gICAgcHVibGljIGV4cGFuZChpZDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmxhdFBvaW50ZXJzW2lkXTtcbiAgICAgICAgcGFyZW50LmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nZXRDb250ZW50KGlkKS5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29sbGFwc2UoaWQ6IG51bWJlcikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZsYXRQb2ludGVyc1tpZF07XG4gICAgICAgIHBhcmVudC5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvb3QkJC5uZXh0KHRoaXMuaW50ZXJuYWxUcmVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRpcmVjdG9yeSB3aXRoIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBjdXJyZW50bHkgb3BlbmVkIGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlRGlyKG5hbWU6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZmVhdHVyZXM/LmNyZWF0ZURpciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3JlYXRlIGRpcmVjdG9yeSBmZWF0dXJlIGlzIGRpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLm9wZW5lZE5vZGUkJC52YWx1ZTtcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZS5jcmVhdGVEaXIocGFyZW50IS5kYXRhLCBuYW1lKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgY3VycmVudGx5IG9wZW5lZCBub2RlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLm9wZW5Ob2RlKHRoaXMub3BlbmVkTm9kZSQkLnZhbHVlIS5pZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuYW1lcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUuXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5ldyBuYW1lIGZvciB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVuYW1lKG5hbWU6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZmVhdHVyZXM/LnJlbmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVuYW1lIGZlYXR1cmUgaXMgZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5zZWxlY3RlZE5vZGVzJCQudmFsdWU7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdGlvbiByZW5hbWUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90aGluZyBzZWxlY3RlZCB0byByZW5hbWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZS5yZW5hbWUobm9kZS5kYXRhLCBuYW1lKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZmVhdHVyZXM/LmRlbGV0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZXRlIGZlYXR1cmUgaXMgZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0ZWROb2RlcyQkLnZhbHVlO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3RoaW5nIHNlbGVjdGVkIHRvIHJlbW92ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0cyA9IHNlbGVjdGlvbi5tYXAoKG5vZGUpID0+IHRoaXMuZmxhdFBvaW50ZXJzW25vZGUuaWRdLmRhdGEpO1xuICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLmRlbGV0ZSh0YXJnZXRzKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIGdpdmVuIGZpbGVzIHRvIHRoZSBjdXJyZW50bHkgb3BlbmVkIGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0gZmlsZXMgVGhlIGZpbGVzIHRvIHVwbG9hZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgdXBsb2FkKGZpbGVzOiBGaWxlTGlzdCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZmVhdHVyZXM/LnVwbG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXBsb2FkIGZlYXR1cmUgaXMgZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm9wZW5lZE5vZGUkJC52YWx1ZSE7XG4gICAgICAgIHRoaXMuZGF0YVNlcnZpY2UudXBsb2FkRmlsZXMobm9kZS5kYXRhLCBmaWxlcykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWxlLlxuICAgICAqL1xuICAgIHB1YmxpYyBkb3dubG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmZlYXR1cmVzPy5kb3dubG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRG93bmxvYWQgZmVhdHVyZSBpcyBkaXNhYmxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5zZWxlY3RlZE5vZGVzJCQudmFsdWVbMF07XG4gICAgICAgIHRoaXMuZGF0YVNlcnZpY2UuZG93bmxvYWRGaWxlKHRhcmdldC5kYXRhKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gbm9kZSBhbmQgZ2V0IGFsbCBwYXJlbnQgbm9kZXNcbiAgICAgKiBJZGVhbCBmb3Igb3BlbmluZyBhIHByZXZpb3VzbHkgb3BlbmVkIG5vZGUgYnkgdmFsdWVcbiAgICAgKi9cbiAgICBwdWJsaWMgb3BlblRyZWUoZGF0YTogRGF0YSkge1xuICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLm9wZW5UcmVlKGRhdGEpLnN1YnNjcmliZSgoZGF0YU5vZGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcy5pbnRlcm5hbFRyZWUsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBkYXRhTm9kZXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGxldCBsYXN0UGFyZW50ID0gdGhpcy5pbnRlcm5hbFRyZWU7XG4gICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyZW50LCBjaGlsZHJlbiB9ID0gcXVldWUuc2hpZnQoKSE7XG4gICAgICAgICAgICAgICAgbGFzdFBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gVXRpbHMuY3JlYXRlTm9kZSh0aGlzLmRhdGFTZXJ2aWNlLmdldE5hbWUoY2hpbGQuZGF0YSksIHBhcmVudC5pZCwgY2hpbGQuaXNMZWFmLCBjaGlsZC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhdFBvaW50ZXJzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzTGVhZiAmJiBjaGlsZC5jaGlsZHJlbiAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZC5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm9vdCQkLm5leHQodGhpcy5pbnRlcm5hbFRyZWUpO1xuICAgICAgICAgICAgdGhpcy5vcGVuZWROb2RlJCQubmV4dChsYXN0UGFyZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlcyQkLm5leHQoW10pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENvbnRlbnQoaWQ6IG51bWJlcikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZsYXRQb2ludGVyc1tpZF07XG5cbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvcGVuIGEgZmlsZSBub2RlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5nZXRDb250ZW50KHBhcmVudC5kYXRhKS5waXBlKFxuICAgICAgICAgICAgdGFwKCh7IGZpbGVzLCBkaXJzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXJOb2RlcyA9IGRpcnMubWFwKChkYXRhKSA9PiBVdGlscy5jcmVhdGVOb2RlKHRoaXMuZGF0YVNlcnZpY2UuZ2V0TmFtZShkYXRhKSwgaWQsIGZhbHNlLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RmlsZU5vZGVzID0gZmlsZXMubWFwKChkYXRhKSA9PiBVdGlscy5jcmVhdGVOb2RlKHRoaXMuZGF0YVNlcnZpY2UuZ2V0TmFtZShkYXRhKSwgaWQsIHRydWUsIGRhdGEpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IG5ld0Rpck5vZGVzLmNvbmNhdChuZXdGaWxlTm9kZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkID0gbmV3Q2hpbGRyZW4uZmlsdGVyKChjKSA9PiAhcGFyZW50LmNoaWxkcmVuLmZpbmQoKG8pID0+IFV0aWxzLmNvbXBhcmVPYmplY3RzKG8uZGF0YSwgYy5kYXRhKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBwYXJlbnQuY2hpbGRyZW4uZmlsdGVyKChvKSA9PiAhbmV3Q2hpbGRyZW4uZmluZCgoYykgPT4gVXRpbHMuY29tcGFyZU9iamVjdHMoby5kYXRhLCBjLmRhdGEpKSk7XG5cbiAgICAgICAgICAgICAgICByZW1vdmVkLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uZmluZEluZGV4KChvKSA9PiBvLmlkID09PSBjLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZsYXRQb2ludGVyc1tjLmlkXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGFkZGVkLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhdFBvaW50ZXJzW2MuaWRdID0gYztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbi5maWx0ZXIoKGMpID0+ICFjLmlzTGVhZik7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVhZkNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuLmZpbHRlcigoYykgPT4gYy5pc0xlYWYpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbiA9IG5vZGVDaGlsZHJlbi5jb25jYXQobGVhZkNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCQkLm5leHQodGhpcy5pbnRlcm5hbFRyZWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG59XG4iXX0=